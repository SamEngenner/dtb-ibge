#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''Brazilian territorial distribution data exporter

The MIT License (MIT)

Copyright (c) 2013 Paulo Freitas

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
'''
# -- Imports ------------------------------------------------------------------
# Built-in modules
import argparse
import collections
import csv
import ftplib
import io
import json
import logging
import os
import plistlib
import re
import sys
import zipfile

# Dependency modules
import lxml.etree
import xlrd
import yaml

# -- Modules enhancements -----------------------------------------------------
yaml.SafeDumper.add_representer(collections.OrderedDict,
    lambda dumper, value: Utils.represent_odict(dumper, u'tag:yaml.org,2002:map', value))

def unsortableWriteDict(self, d):
    self.beginElement('dict')
    items = d.items()

    for key, value in items:
        if not isinstance(key, (str, unicode)):
            raise TypeError('keys must be strings')

        self.simpleElement('key', key)
        self.writeValue(value)

    self.endElement('dict')

plistlib.PlistWriter.writeDict = unsortableWriteDict

# -- Module docstrings --------------------------------------------------------
__author__ = 'Paulo Freitas <me@paulofreitas.me>'
__copyright__ = 'Copyright (c) 2013 Paulo Freitas'
__license__ = 'MIT'
__version__ = '1.0-dev'
__usage__ = '%(prog)s -b BASE -f FORMAT [-m] [-o FILENAME]'
__epilog__ = 'Report bugs and feature requests to https://github.com/paulofreitas/dtb-ibge/issues.'

# -- Module constants ---------------------------------------------------------
FORMAT_CSV = 'csv'
FORMAT_JSON = 'json'
FORMAT_PLIST = 'plist'
FORMAT_SQL = 'sql'
FORMAT_XML = 'xml'
FORMAT_YAML = 'yaml'
FORMAT_ALL = (FORMAT_CSV, FORMAT_JSON, FORMAT_PLIST, FORMAT_SQL, FORMAT_XML, FORMAT_YAML)

# -- Module initialization ----------------------------------------------------
formatter = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', '%H:%M:%S')
log_handler = logging.StreamHandler(sys.stdout)
log_handler.setFormatter(formatter)
logger = logging.getLogger('dtb')
logger.addHandler(log_handler)

# -- Classes ------------------------------------------------------------------
class Database(object):
    _tables = ('uf', 'mesorregiao', 'microrregiao', 'municipio', 'distrito', 'subdistrito')
    _fields = {
        'uf':
            ('id', 'nome'),
        'mesorregiao':
            ('id', 'id_uf', 'nome'),
        'microrregiao': 
            ('id', 'id_mesorregiao', 'id_uf', 'nome'),
        'municipio':
            ('id', 'id_microrregiao', 'id_mesorregiao', 'id_uf', 'nome'),
        'distrito':
            ('id', 'id_municipio', 'id_microrregiao', 'id_mesorregiao', 'id_uf', 'nome'),
        'subdistrito':
            ('id', 'id_distrito', 'id_municipio', 'id_microrregiao', 'id_mesorregiao', 'id_uf', 'nome')
    }
    _cols = []
    _rows = []
    _data = {}
    _rawdata = None

    def __init__(self, base):
        self._base = str(base)
        self._name = 'dtb_{}'.format(self._base)

        for table_name in self._tables:
            self._cols.append('id_' + table_name)
            self._cols.append('nome_' + table_name)
            self._data[table_name] = []

class Exporter(object):
    def __init__(self, db, minified=False):
        self._db = db
        self._minified = minified

    def __str__(self):
        raise NotImplementedError

class CSV(Exporter):
    def __str__(self):
        csv_file = io.BytesIO()
        csv_writer = csv.writer(csv_file,
                                quoting=csv.QUOTE_MINIMAL if self._minified else csv.QUOTE_NONNUMERIC,
                                lineterminator='\n')

        csv_writer.writerow([col.encode('utf-8') for col in self._db._cols])

        for row in self._db._rows:
            csv_writer.writerow([bytes(col) if type(col) == str else col for col in filter(None, row)])

        return csv_file.getvalue()

class JSON(Exporter):
    def __str__(self):
        json_obj = collections.OrderedDict()

        for table_name in self._db._tables:
            json_obj[table_name] = collections.OrderedDict()

            for item in self._db._data[table_name]:
                item_obj = collections.OrderedDict()

                for key in self._db._fields[table_name]:
                    item_obj[key] = item[key]

                item_id = item_obj['id']
                del item_obj['id']
                json_obj[table_name][item_id] = item_obj

        if self._minified:
            json_str = json.dumps(json_obj, separators=(',', ':'))
        else:
            json_str = json.dumps(json_obj, indent=2)

        return json_str

class plist(Exporter):
    def __str__(self):
        plist_obj = collections.OrderedDict()
    
        for table_name in self._db._tables:
            plist_obj[table_name] = collections.OrderedDict()

            for item in self._db._data[table_name]:
                item_obj = collections.OrderedDict()

                for key in self._db._fields[table_name]:
                    item_obj[key] = item[key].decode('utf-8') if type(item[key]) == str else item[key]

                item_id = str(item_obj['id'])
                del item_obj['id']
                plist_obj[table_name][item_id] = item_obj

        plist_str = plistlib.writePlistToString(plist_obj)

        return re.sub('[\n\t]+', '', plist_str) if self._minified else plist_str

class SQL(Exporter):
    def __table(self, table_name, *args):
        return 'CREATE TABLE {} (\n{}\n);\n'.format(table_name, '\n'.join(args))

    def __column(self, column_name, column_type):
        return '    {} {},'.format(column_name, column_type)

    def __primaryKey(self, pk_name, pk_column):
        return '''    CONSTRAINT {}
        PRIMARY KEY ({}),'''.format(pk_name, pk_column)

    def __foreignKey(self, fk_name, fk_column, foreign_table, foreign_column):
        return '''    CONSTRAINT {}
        FOREIGN KEY ({})
            REFERENCES {}({})'''.format(fk_name, fk_column, foreign_table, foreign_column)

    def __index(self, index_name, table_name, indexed_column):
        return 'CREATE INDEX {} ON {} ({});'.format(index_name, table_name, indexed_column)

    def __indexes(self, *indexes):
        return '\n'.join(indexes)

    def __insert(self, table_name, *columns):
        return 'INSERT INTO {} VALUES ({});'.format(table_name, ', '.join(columns))

    def __insertField(self, field_name, field_type):
        repl_field = '{' + field_name + '}'

        return repr(repl_field) if field_type == str else repl_field

    def __init__(self, db, minified):
        super(SQL, self).__init__(db, minified)

        self._tables = {
            'uf': self.__table(
                'uf',
                self.__column('id', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(32) NOT NULL'),
                self.__primaryKey('pk_uf', 'id')
            ),
            'mesorregiao': self.__table(
                'mesorregiao',
                self.__column('id', 'SMALLINT NOT NULL'),
                self.__column('id_uf', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(64) NOT NULL'),
                self.__primaryKey('pk_mesorregiao', 'id'),
                self.__foreignKey('fk_mesorregiao_uf', 'id_uf', 'uf', 'id')
            ),
            'microrregiao': self.__table(
                'microrregiao',
                self.__column('id', 'INTEGER NOT NULL'),
                self.__column('id_mesorregiao', 'SMALLINT NOT NULL'),
                self.__column('id_uf', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(64) NOT NULL'),
                self.__primaryKey('pk_microrregiao', 'id'),
                self.__foreignKey('fk_microrregiao_mesorregiao', 'id_mesorregiao', 'mesorregiao', 'id'),
                self.__foreignKey('fk_microrregiao_uf', 'id_uf', 'uf', 'id')
            ),
            'municipio': self.__table(
                'municipio',
                self.__column('id', 'INTEGER NOT NULL'),
                self.__column('id_microrregiao', 'INTEGER NOT NULL'),
                self.__column('id_mesorregiao', 'SMALLINT NOT NULL'),
                self.__column('id_uf', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(64) NOT NULL'),
                self.__primaryKey('pk_municipio', 'id'),
                self.__foreignKey('fk_municipio_microrregiao', 'id_microrregiao', 'microrregiao', 'id'),
                self.__foreignKey('fk_municipio_mesorregiao', 'id_mesorregiao', 'mesorregiao', 'id'),
                self.__foreignKey('fk_municipio_uf', 'id_uf', 'uf', 'id')
            ),
            'distrito': self.__table(
                'distrito',
                self.__column('id', 'INTEGER NOT NULL'),
                self.__column('id_municipio', 'INTEGER NOT NULL'),
                self.__column('id_microrregiao', 'INTEGER NOT NULL'),
                self.__column('id_mesorregiao', 'SMALLINT NOT NULL'),
                self.__column('id_uf', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(64) NOT NULL'),
                self.__primaryKey('pk_distrito', 'id'),
                self.__foreignKey('fk_distrito_municipio', 'id_municipio', 'municipio', 'id'),
                self.__foreignKey('fk_distrito_microrregiao', 'id_microrregiao', 'microrregiao', 'id'),
                self.__foreignKey('fk_distrito_mesorregiao', 'id_mesorregiao', 'mesorregiao', 'id'),
                self.__foreignKey('fk_distrito_uf', 'id_uf', 'uf', 'id')
            ),
            'subdistrito': self.__table(
                'subdistrito',
                self.__column('id', 'BIGINT NOT NULL'),
                self.__column('id_distrito', 'INTEGER NOT NULL'),
                self.__column('id_municipio', 'INTEGER NOT NULL'),
                self.__column('id_microrregiao', 'INTEGER NOT NULL'),
                self.__column('id_mesorregiao', 'SMALLINT NOT NULL'),
                self.__column('id_uf', 'SMALLINT NOT NULL'),
                self.__column('nome', 'VARCHAR(64) NOT NULL'),
                self.__primaryKey('pk_subdistrito', 'id'),
                self.__foreignKey('fk_subdistrito_distrito', 'id_distrito', 'distrito', 'id'),
                self.__foreignKey('fk_subdistrito_municipio', 'id_municipio', 'municipio', 'id'),
                self.__foreignKey('fk_subdistrito_microrregiao', 'id_microrregiao', 'microrregiao', 'id'),
                self.__foreignKey('fk_subdistrito_mesorregiao', 'id_mesorregiao', 'mesorregiao', 'id'),
                self.__foreignKey('fk_subdistrito_uf', 'id_uf', 'uf', 'id')
            )
        }
        self._indexes = {
            'mesorregiao': self.__index('fk_mesorregiao_uf', 'mesorregiao', 'id_uf'),
            'microrregiao': self.__indexes(
                self.__index('fk_microrregiao_mesorregiao', 'microrregiao', 'id_mesorregiao'),
                self.__index('fk_microrregiao_uf', 'microrregiao', 'id_uf')
            ),
            'municipio': self.__indexes(
                self.__index('fk_municipio_microrregiao', 'municipio', 'id_microrregiao'),
                self.__index('fk_municipio_mesorregiao', 'municipio', 'id_mesorregiao'),
                self.__index('fk_municipio_uf', 'municipio', 'id_uf')
            ),
            'distrito': self.__indexes(
                self.__index('fk_distrito_municipio', 'distrito', 'id_municipio'),
                self.__index('fk_distrito_microrregiao', 'distrito', 'id_microrregiao'),
                self.__index('fk_distrito_mesorregiao', 'distrito', 'id_mesorregiao'),
                self.__index('fk_distrito_uf', 'distrito', 'id_uf')
            ),
            'subdistrito': self.__indexes(
                self.__index('fk_subdistrito_distrito', 'subdistrito', 'id_distrito'),
                self.__index('fk_subdistrito_municipio', 'subdistrito', 'id_municipio'),
                self.__index('fk_subdistrito_microrregiao', 'subdistrito', 'id_microrregiao'),
                self.__index('fk_subdistrito_mesorregiao', 'subdistrito', 'id_mesorregiao'),
                self.__index('fk_subdistrito_uf', 'subdistrito', 'id_uf')
            )
        }
        self._inserts = {
            'uf': self.__insert(
                'uf',
                self.__insertField('id', int),
                self.__insertField('nome', str)
            ),
            'mesorregiao': self.__insert(
                'mesorregiao',
                self.__insertField('id', int),
                self.__insertField('id_uf', int),
                self.__insertField('nome', str)
            ),
            'microrregiao': self.__insert(
                'microrregiao',
                self.__insertField('id', int),
                self.__insertField('id_mesorregiao', int),
                self.__insertField('id_uf', int),
                self.__insertField('nome', str)
            ),
            'municipio': self.__insert(
                'municipio',
                self.__insertField('id', int),
                self.__insertField('id_microrregiao', int),
                self.__insertField('id_mesorregiao', int),
                self.__insertField('id_uf', int),
                self.__insertField('nome', str)
            ),
            'distrito': self.__insert(
                'distrito',
                self.__insertField('id', int),
                self.__insertField('id_municipio', int),
                self.__insertField('id_microrregiao', int),
                self.__insertField('id_mesorregiao', int),
                self.__insertField('id_uf', int),
                self.__insertField('nome', str)
            ),
            'subdistrito': self.__insert(
                'subdistrito',
                self.__insertField('id', int),
                self.__insertField('id_distrito', int),
                self.__insertField('id_municipio', int),
                self.__insertField('id_microrregiao', int),
                self.__insertField('id_mesorregiao', int),
                self.__insertField('id_uf', int),
                self.__insertField('nome', str)
            )
        }

    def __str__(self):
        sql = ''

        for table_name in self._db._tables:
            if not self._minified:
                sql += '''
--
-- Table structure for table "{}"
--
'''.format(table_name)

            sql += self._tables[table_name]

            if table_name in self._indexes:
                sql += self._indexes[table_name]

            if not self._minified:
                sql += '''
--
-- Dumping data for table "{}"
--
'''.format(table_name)

            for item in self._db._data[table_name]:
                data = collections.OrderedDict()

                for key in self._db._fields[table_name]:
                    data[key] =\
                        item[key] if type(item[key]) == int else Utils.addslashes(item[key])

                sql += self._inserts[table_name].strip().format(**data) + '\n'

        sql = sql.strip()

        if self._minified:
            sql = re.sub('([;(])\s+', r'\1', sql)
            sql = re.sub(',\s(?=\')|,\s+', ',', sql)
            sql = re.sub('\s+', ' ', sql)
            sql = re.sub('(\W)\s(\W)', r'\1\2', sql)

        return sql

class XML(Exporter):
    def __str__(self):
        database = lxml.etree.Element('database', name=self._db._name)

        for table_name in self._db._tables:
            if not self._minified:
                database.append(lxml.etree.Comment(' Table {} '.format(table_name)))

            table = lxml.etree.SubElement(database, 'table', name=table_name)

            for item in self._db._data[table_name]:
                row = lxml.etree.SubElement(table, 'row')

                for field_name in self._db._fields[table_name]:
                    lxml.etree.SubElement(row, 'field',
                        name=field_name).text = str(item[field_name]).decode('utf-8')

        return lxml.etree.tostring(database,
                                   pretty_print=not self._minified,
                                   xml_declaration=True,
                                   encoding='utf-8')

class YAML(Exporter):
    def __str__(self):
        yaml_obj = collections.OrderedDict()

        for table_name in self._db._tables:
            yaml_obj[table_name] = collections.OrderedDict()

            for item in self._db._data[table_name]:
                item_obj = collections.OrderedDict()

                for key in self._db._fields[table_name]:
                    item_obj[key] = item[key]

                item_id = item_obj['id']
                del item_obj['id']
                yaml_obj[table_name][item_id] = item_obj

        if self._minified:
            options = {'default_flow_style': True, 'width': 2e6, 'indent': 0}
        else:
            options = {'default_flow_style': False}

        yaml_str = yaml.safe_dump(yaml_obj, **options)

        return yaml_str.replace('}, ', '},') if self._minified else yaml_str

class DTB(object):
    def __init__(self, base):
        self._db = Database(base)

    def download(self):
        ftp = ftplib.FTP('geoftp.ibge.gov.br')
        logger.debug('Connecting to FTP server...')
        ftp.connect()
        logger.debug('Logging into the FTP server...')
        ftp.login()
        ftp.cwd('organizacao_territorial/divisao_territorial')

        bases_available = [item for item in ftp.nlst() if item.isdigit()]

        if not self._db._base in bases_available:
            raise Exception('This base is not available to download.')

        ftp.cwd(self._db._base)
        zip_data = io.BytesIO()
        logger.info('Retrieving database...')
        ftp.retrbinary('RETR dtb_{}.zip'.format(self._db._base), zip_data.write)

        with zipfile.ZipFile(zip_data, 'r') as zip:
            logger.info('Reading database...')
            self._db._rawdata = zip.open('DTB {}.xls'.format(self._db._base)).read()

        return self

    def parse(self):
        logger.debug('Parsing database...')
        xls = xlrd.open_workbook(file_contents=self._db._rawdata,
                                 logfile=open(os.devnull, 'w'))
        sheet = xls.sheet_by_index(0)

        for row_id in xrange(sheet.nrows):
            if row_id == 0:
                continue

            row_data = [value.encode('utf-8') for value in sheet.row_values(row_id)]

            id_uf, nome_uf, id_mesorregiao, nome_mesorregiao, \
            id_microrregiao, nome_microrregiao, id_municipio, nome_municipio, \
            id_distrito, nome_distrito, id_subdistrito, nome_subdistrito = row_data

            id_subdistrito = int(id_uf + id_municipio + id_distrito + id_subdistrito) if id_subdistrito else None
            id_distrito = int(id_uf + id_municipio + id_distrito)
            id_municipio = int(id_uf + id_municipio)
            id_microrregiao = int(id_microrregiao)
            id_mesorregiao = int(id_mesorregiao)
            id_uf = int(id_uf)

            self._db._rows.append([id_uf, nome_uf, id_mesorregiao, nome_mesorregiao,
                                   id_microrregiao, nome_microrregiao, id_municipio,
                                   nome_municipio, id_distrito, nome_distrito,
                                   id_subdistrito, nome_subdistrito or None])

            # uf
            uf = Struct()
            uf.id = id_uf
            uf.nome = nome_uf

            if not uf in self._db._data['uf']:
                self._db._data['uf'].append(uf)

            # mesorregiao
            mesorregiao = Struct(
                id=id_mesorregiao,
                id_uf=id_uf,
                nome=nome_mesorregiao
            )

            if not mesorregiao in self._db._data['mesorregiao']:
                self._db._data['mesorregiao'].append(mesorregiao)

            # microrregiao
            microrregiao = Struct(
                id=id_microrregiao,
                id_mesorregiao=id_mesorregiao,
                id_uf=id_uf,
                nome=nome_microrregiao
            )

            if not microrregiao in self._db._data['microrregiao']:
                self._db._data['microrregiao'].append(microrregiao)

            # municipio
            municipio = Struct(
                id=id_municipio,
                id_microrregiao=id_microrregiao,
                id_mesorregiao=id_mesorregiao,
                id_uf=id_uf,
                nome=nome_municipio
            )

            if not municipio in self._db._data['municipio']:
                self._db._data['municipio'].append(municipio)

            # distrito
            distrito = Struct(
                id=id_distrito,
                id_municipio=id_municipio,
                id_microrregiao=id_microrregiao,
                id_mesorregiao=id_mesorregiao,
                id_uf=id_uf,
                nome=nome_distrito
            )

            if not distrito in self._db._data['distrito']:
                self._db._data['distrito'].append(distrito)

            # subdistrito
            if id_subdistrito:
                subdistrito = Struct(
                    id=id_subdistrito,
                    id_distrito=id_distrito,
                    id_municipio=id_municipio,
                    id_microrregiao=id_microrregiao,
                    id_mesorregiao=id_mesorregiao,
                    id_uf=id_uf,
                    nome=nome_subdistrito
                )

                if not subdistrito in self._db._data['subdistrito']:
                    self._db._data['subdistrito'].append(subdistrito)

        return self

    def export(self, format, minified=False, filename=None):
        if not format in FORMAT_ALL:
            raise Exception('Unsupported output format.')

        exporters = {}
        exporters[FORMAT_CSV] = CSV
        exporters[FORMAT_JSON] = JSON
        exporters[FORMAT_PLIST] = plist
        exporters[FORMAT_SQL] = SQL
        exporters[FORMAT_XML] = XML
        exporters[FORMAT_YAML] = YAML
        exporter = exporters[format]
        logger.info('Exporting database to {} format...'.format(exporter.__name__))
        data = str(exporter(self._db, minified))
        logger.info('Done.')

        if filename:
            if filename == 'auto':
                filename = 'dtb.' + format

            open(filename, 'w').write(data)
        else:
            sys.stdout.write(data)

class Struct(dict):
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        self[name] = value

    def copy(self):
        return Struct(dict.copy(self))

class Utils(object):
    @staticmethod
    def addslashes(value):
        return value.replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'")

    @staticmethod
    def represent_odict(dump, tag, mapping, flow_style=None):
        '''Make PyYAML output and OrderedDict.
        Credits: https://gist.github.com/miracle2k/3184458/
        '''
        value = []
        node = yaml.MappingNode(tag, value, flow_style=flow_style)

        if dump.alias_key is not None:
            dump.represented_objects[dump.alias_key] = node

        best_style = True

        if hasattr(mapping, 'items'):
            mapping = mapping.items()

        for item_key, item_value in mapping:
            node_key = dump.represent_data(item_key)
            node_value = dump.represent_data(item_value)

            if not (isinstance(node_key, yaml.ScalarNode) and not node_key.style):
                best_style = False

            if not (isinstance(node_value, yaml.ScalarNode) and not node_value.style):
                best_style = False

            value.append((node_key, node_value))

            if flow_style is None:
                if dump.default_flow_style is not None:
                    node.flow_style = dump.default_flow_style
                else:
                    node.flow_style = best_style

        return node

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
                                     usage=__usage__,
                                     epilog=__epilog__,
                                     conflict_handler='resolve',
                                     formatter_class=argparse.RawTextHelpFormatter)
    g_global = parser.add_argument_group('Global options')
    g_global.add_argument('-h', '--help',
                          action='help',
                          help='Display this information')
    g_global.add_argument('-v', '--version',
                          action='version',
                          version='%(prog)s ' + __version__,
                          help='Show version information and exit')
    g_global.add_argument('-V', '--verbose',
                          action='store_true',
                          help='Display informational messages and warnings')

    g_export = parser.add_argument_group('Export options')
    g_export.add_argument('-b', '--base',
                          type=int,
                          help='Database year to export to.')
    g_export.add_argument('-f', '--format',
                          metavar='FORMAT',
                          choices=FORMAT_ALL,
                          help='Format to export the database.\nOptions: %(choices)s')
    g_export.add_argument('-m', '--minify',
                          dest='minified',
                          action='store_true',
                          help='Minifies output file whenever possible.')
    g_export.add_argument('-o', '--out',
                          dest='filename',
                          nargs='?',
                          const='auto',
                          help='Specify a file to write the export to.\n' \
                              + 'If none are specified, %(prog)s writes data to standard output.')
    args = parser.parse_args()

    if not args.base:
        parser.error('You need to specify the database year you want to export.')

    if not args.format:
        parser.error('You need to specify the database format you want to export.')

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    try:
        dtb = DTB(args.base)
        dtb.download().parse().export(args.format, args.minified, args.filename)
    except Exception as e:
        sys.stdout.write('EXCEPTION CAUGHT: {}: {}\n'.format(type(e).__name__, e.message))
        sys.exit(1)